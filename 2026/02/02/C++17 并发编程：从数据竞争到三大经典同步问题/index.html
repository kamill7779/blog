
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 8.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>C++17 并发编程：从数据竞争到三大经典同步问题 - Kam1L blog</title>

  
    <meta name="description" content="并发到底解决什么：并发 vs 并行、线程模型与现实约束1.1 并发（Concurrency）vs 并行（Parallelism）  Concurrency is when two tasks can start, run, and complete in overlapping time periods. Parallelism is when tasks literally run at the">
<meta property="og:type" content="article">
<meta property="og:title" content="C++17 并发编程：从数据竞争到三大经典同步问题">
<meta property="og:url" content="https://kamill7779.github.io/blog/2026/02/02/C++17%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E5%88%B0%E4%B8%89%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/">
<meta property="og:site_name" content="Kam1L blog">
<meta property="og:description" content="并发到底解决什么：并发 vs 并行、线程模型与现实约束1.1 并发（Concurrency）vs 并行（Parallelism）  Concurrency is when two tasks can start, run, and complete in overlapping time periods. Parallelism is when tasks literally run at the">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kamill7779.github.io/blog/assets/avatar.jpg">
<meta property="article:published_time" content="2026-02-02T15:30:00.000Z">
<meta property="article:modified_time" content="2026-02-02T17:23:02.000Z">
<meta property="article:author" content="kamil.liu">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="os">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://kamill7779.github.io/blog/assets/avatar.jpg">
  
  
  
  <meta name="keywords" content="cpp,os">

  <!-- feed -->
  

  <link rel="stylesheet" href="/blog/css/main.css?v=1.33.1">


  
    <link rel="shortcut icon" href="https://kamill7779.github.io/blog/assets/favicon.ico">
  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"kamil.liu","sameAs":[],"image":"https://kamill7779.github.io/blog/assets/avatar.jpg"},"dateCreated":"2026-02-02T23:30:00+08:00","dateModified":"2026-02-03T01:23:02+08:00","datePublished":"2026-02-02T23:30:00+08:00","description":"","headline":"C++17 并发编程：从数据竞争到三大经典同步问题","mainEntityOfPage":{"@type":"WebPage","@id":"https://kamill7779.github.io/blog/2026/02/02/C++17%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E5%88%B0%E4%B8%89%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"},"publisher":{"@type":"Organization","name":"kamil.liu","sameAs":[],"image":"https://kamill7779.github.io/blog/assets/avatar.jpg","logo":{"@type":"ImageObject","url":"https://kamill7779.github.io/blog/assets/avatar.jpg"}},"url":"https://kamill7779.github.io/blog/2026/02/02/C++17%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E5%88%B0%E4%B8%89%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/","keywords":"cpp, os","thumbnailUrl":"/blog/assets/posts/cpp17-concurrency/cover.jpg","image":1}</script>
  
</head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="https://kamill7779.github.io/blog/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://kamill7779.github.io/blog/assets/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="https://kamill7779.github.io/blog/"><div class="main">Kam1L blog</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"><a class="nav-item active" title="首页" href="/blog/"><span>首页</span></a><a class="nav-item" title="时间线" href="/blog/timeline/"><span>时间线</span></a><a class="nav-item" title="关于" href="/blog/about/"><span>关于</span></a></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>

<widget class="widget-wrapper related post-list"><div class="widget-header dis-select"><span class="name">专栏：C++系列</span></div><div class="widget-body"><a class="item active" href="/blog/2026/02/02/C++17%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E5%88%B0%E4%B8%89%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"><span class="title">C++17 并发编程：从数据竞争到三大经典同步问题</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a></div></widget>

<widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/blog/2026/02/02/C++17%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E5%88%B0%E4%B8%89%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"><span class="title">C++17 并发编程：从数据竞争到三大经典同步问题</span></a><a class="item title" href="/blog/2026/02/01/hello-world/"><span class="title">Hello World</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/kamill7779" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg"/></a><a class="social" href="mailto:kamill7779@outlook.com" rel="noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/942ebbf1a4b91.svg"/></a><a class="social" href="https://kamill7779.github.io/blog/atom.xml" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3616429.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top"><img class="lazy bg" data-src="/blog/assets/posts/cpp17-concurrency/banner.jpg">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/blog/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/blog/topic/">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/blog/2026/02/02/C++17%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E5%88%B0%E4%B8%89%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/">C++系列</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2026-02-02T15:30:00.000Z">2026-02-02</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2026-02-02T17:23:02.000Z">2026-02-03</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>C++17 并发编程：从数据竞争到三大经典同步问题</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h2 id="并发到底解决什么：并发-vs-并行、线程模型与现实约束"><a href="#并发到底解决什么：并发-vs-并行、线程模型与现实约束" class="headerlink" title="并发到底解决什么：并发 vs 并行、线程模型与现实约束"></a>并发到底解决什么：并发 vs 并行、线程模型与现实约束</h2><h3 id="1-1-并发（Concurrency）vs-并行（Parallelism）"><a href="#1-1-并发（Concurrency）vs-并行（Parallelism）" class="headerlink" title="1.1 并发（Concurrency）vs 并行（Parallelism）"></a>1.1 并发（Concurrency）vs 并行（Parallelism）</h3><blockquote>
<ul>
<li><strong><font style="color:rgb(51, 51, 51);">Concurrency</font></strong><font style="color:rgb(51, 51, 51);"> is when two tasks can start, run, and complete in overlapping time periods. </font><strong><font style="color:rgb(51, 51, 51);">Parallelism</font></strong><font style="color:rgb(51, 51, 51);"> is when tasks literally run at the same time, eg. on a multi-core processor.</font></li>
<li><strong><font style="color:rgb(51, 51, 51);">Concurrency</font></strong><font style="color:rgb(51, 51, 51);"> is the composition of independently executing processes, while </font><strong><font style="color:rgb(51, 51, 51);">parallelism</font></strong><font style="color:rgb(51, 51, 51);"> is the simultaneous execution of (possibly related) computations.</font></li>
<li><strong><font style="color:rgb(51, 51, 51);">Concurrency</font></strong><font style="color:rgb(51, 51, 51);"> is about dealing with lots of things at once. </font><strong><font style="color:rgb(51, 51, 51);">Parallelism</font></strong><font style="color:rgb(51, 51, 51);"> is about doing lots of things at once.</font></li>
<li><font style="color:rgb(51, 51, 51);">An application can be </font><strong><font style="color:rgb(51, 51, 51);">concurrent – but not paralle</font></strong><font style="color:rgb(51, 51, 51);">l, which means that it processes more than one task at the same time, but no two tasks are executing at same time instant.</font></li>
<li><font style="color:rgb(51, 51, 51);">An application can be </font><strong><font style="color:rgb(51, 51, 51);">parallel – but not concurrent</font></strong><font style="color:rgb(51, 51, 51);">, which means that it processes multiple sub-tasks of a task in multi-core CPU at same time.</font></li>
<li><font style="color:rgb(51, 51, 51);">An application can be </font><strong><font style="color:rgb(51, 51, 51);">neither parallel – nor concurrent</font></strong><font style="color:rgb(51, 51, 51);">, which means that it processes all tasks one at a time, sequentially.</font></li>
<li><font style="color:rgb(51, 51, 51);">An application can be </font><strong><font style="color:rgb(51, 51, 51);">both parallel – and concurrent</font></strong><font style="color:rgb(51, 51, 51);">, which means that it processes multiple tasks concurrently in multi-core CPU at same time.</font></li>
</ul>
<p><font style="color:rgb(51, 51, 51);">	</font><strong><font style="color:rgb(51, 51, 51);">Vipin Jain.</font></strong><font style="color:rgb(51, 51, 51);"> </font><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4844637/what-is-the-difference-between-concurrency-parallelism-and-asynchronous-methods"><font style="color:rgb(0, 0, 0);">Differences between concurrency vs. parallelism</font></a></p>
</blockquote>
<p><strong>并发</strong>可以理解为一种“同时”的假象：操作系统把 CPU 的时间切成很多很短的时间片，在多个任务之间快速切换。由于切换速度足够快，人就会感觉好像所有任务都在同时运行。哪怕你的电脑只有单核 CPU，依然可以一边听歌、一边下载文件、一边开着编辑器敲代码——<strong>任务在宏观上同时进行，微观上交替推进</strong>。</p>
<!-- 这是一张图片，ocr 内容为： -->
<p><img src="/blog/blog/assets/posts/cpp17-concurrency/1770021644847-14b81a72-16db-42e5-86c5-ef40d9f3be07.png" alt="并发：同一时间段内可以交替处理多个操作"></p>
<p>而<strong>并行</strong>则是“真正的同时”：它依赖多个计算单元（多核 CPU、多个处理器，甚至 GPU 的大量计算核心），让多个任务在同一时刻<strong>各占一个核心</strong>执行。当你有 4 核 CPU 时，理论上可以让 4 段计算密集型任务在同一时间段内各跑各的，这才是并行的典型场景：<strong>任务在宏观和微观上都同时推进</strong>。</p>
<blockquote>
<p>并发更多提升的是系统的<strong>响应性</strong>与<strong>吞吐能力</strong>（例如：程序不会卡死在某个慢操作上，而是能继续处理别的请求）；并行才更直接地对应“计算更快”（例如：把一个大计算拆成多块，让多个核心一起算）  </p>
</blockquote>
<!-- 这是一张图片，ocr 内容为： -->
<p><img src="/blog/blog/assets/posts/cpp17-concurrency/1770021651028-0a84c6d2-ac2c-43b7-b7b7-d79d85a4833b.png" alt="并行：同一时刻内同时处理多个操作"></p>
<h3 id="1-2-进程-vs-线程：为什么同步问题通常在“线程共享内存”下最典型"><a href="#1-2-进程-vs-线程：为什么同步问题通常在“线程共享内存”下最典型" class="headerlink" title="1.2 进程 vs 线程：为什么同步问题通常在“线程共享内存”下最典型"></a>1.2 进程 vs 线程：为什么同步问题通常在“线程共享内存”下最典型</h3><blockquote>
<p>在操作系统视角里，**进程（process）<strong>和</strong>线程（thread）**都可以理解为“正在运行的程序实体”，但它们的核心区别在于：<strong>资源隔离的边界在哪里</strong>。</p>
<p><strong><font style="color:rgb(0, 0, 0);">进程是操作系统资源分配的最小单位</font></strong><font style="color:rgb(0, 0, 0);">,一个进程可以包含多个线程。每个进程都拥有独立的内存空间,系统再进行资源分配时会为进程分配独立的内存区域。而</font><strong><font style="color:rgb(0, 0, 0);">线程是执行程序的最小单位</font></strong><font style="color:rgb(0, 0, 0);">,多个线程共享同一个进程的内存空间。</font></p>
</blockquote>
<h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1) 进程"></a>1) 进程</h4><p>进程通常被当作操作系统进行资源管理与隔离的基本单位。你可以把一个进程理解为：</p>
<ul>
<li>一套独立的<strong>虚拟地址空间</strong>（进程认为自己拥有整个操作系统的全部资源）</li>
<li>一组独立的资源：打开的文件描述符表、信号处理方式、当前工作目录、权限信息等</li>
</ul>
<p>在 Linux 里，进程的核心管理结构通常被抽象为 <strong>PCB（Process Control Block，进程控制块）</strong>。在实现层面，Linux 里对应的是 <code>task_struct</code> 之类的内核数据结构，用来记录这个执行实体的状态：调度信息、寄存器上下文、信号、内存映射、文件表指针等。</p>
<blockquote>
<ul>
<li><strong><font style="color:rgb(39, 50, 57);">Process state:</font></strong> Stores whether the process is running, waiting, ready, or terminated.</li>
<li><strong><font style="color:rgb(39, 50, 57);">Process number Or PID:</font></strong> Every process is assigned a unique id known as process ID or PID.</li>
<li><strong><font style="color:rgb(39, 50, 57);">Program counter:</font></strong><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/operating-systems/what-is-program-counter/"><font style="color:rgb(53, 121, 96);">Program Counter</font></a> stores the address of the next instruction that is to be executed for the process.</li>
<li><strong><font style="color:rgb(39, 50, 57);">Register:</font></strong><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/computer-organization-architecture/different-classes-of-cpu-registers/"><font style="color:rgb(53, 121, 96);">Registers</font></a> in the PCB, it is a data structure. When a processes is running and it’s time slice expires, the current value of process specific registers would be stored in the PCB and the process would be swapped out. When the process is scheduled to be run, the register values is read from the PCB and written to the CPU registers. This is the main purpose of the registers in the PCB.</li>
<li><strong><font style="color:rgb(39, 50, 57);">Memory limits:</font></strong> This field contains the information about <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/operating-systems/memory-management-in-operating-system/"><font style="color:rgb(53, 121, 96);">memory management system</font></a> used by the operating system. This may include page tables, segment tables, etc.</li>
<li><strong><font style="color:rgb(39, 50, 57);">List of Open files:</font></strong> This information includes the list of files opened for a process.</li>
</ul>
</blockquote>
<p>不需要记住所有字段，只要抓住一点：<strong>PCB &#x2F; <code>task_struct</code></strong> 是内核用来“记住一个执行实体是谁、跑到哪、拥有什么资源”的地方。</p>
<!-- 这是一张图片，ocr 内容为： -->
<p><img src="/blog/blog/assets/posts/cpp17-concurrency/1770023549547-d03222f8-71ba-46b7-9e13-87d331f05981.webp" alt="Terminologies used in Process Control Block"></p>
<h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2) 线程"></a>2) 线程</h4><p>线程更像是进程内部的“执行流”。同一个进程内的多个线程，通常共享：</p>
<ul>
<li>同一份虚拟地址空间（也就是同一份代码&#x2F;全局变量&#x2F;堆内存等）</li>
<li>同一组进程级资源（例如文件描述符表等）</li>
</ul>
<p>但每个线程<strong>也有自己的私有部分</strong>，最典型的是：</p>
<ul>
<li><strong>线程栈（stack）</strong>：函数调用链、本地变量（自动变量）通常都在这里</li>
<li><strong>寄存器上下文</strong>：包括程序计数器、栈指针等（用于上下文切换）</li>
<li>线程本地存储（TLS）等（可选点到）</li>
</ul>
<p>Linux 里“线程”和“进程”在内核层面其实非常接近：它们都可以用同一种内核对象（仍然是 <code>task_struct</code>）来表示。差别更多体现在：<strong>不同的 <code>task_struct</code> 是否共享同一份资源指针（比如地址空间、文件表）</strong>。也就是说，线程本质上是“共享资源更多的任务”。</p>
<h4 id="3-程序的虚拟内存布局：为什么线程共享内存会触发同步问题"><a href="#3-程序的虚拟内存布局：为什么线程共享内存会触发同步问题" class="headerlink" title="3) 程序的虚拟内存布局：为什么线程共享内存会触发同步问题"></a>3) 程序的虚拟内存布局：为什么线程共享内存会触发同步问题</h4><p>要解释为什么线程共享内存会触发同步问题，关键是搞清楚：线程到底共享了哪些内存区域。</p>
<p>一个典型进程的虚拟地址空间可以粗略分成这些部分：</p>
<ul>
<li><strong>代码段（text segment）</strong>：程序机器指令，通常是只读（共享也无所谓，因为不改）</li>
<li><strong>只读数据段（rodata）</strong>：字符串常量、只读全局常量等</li>
<li><strong>已初始化数据段（data segment）</strong>：带初值的全局&#x2F;静态变量</li>
<li><strong>未初始化数据段（BSS segment）</strong>：未显式初始化的全局&#x2F;静态变量（启动时会被置 0）</li>
<li><strong>堆（heap）</strong>：动态内存分配区域（<code>new/malloc</code>），通常由所有线程共享</li>
<li><strong>栈（stack）</strong>：每个线程<strong>各自独立</strong>的一块栈空间（局部变量一般线程私”，前提是你没把它的地址共享出去）</li>
</ul>
<!-- 这是一张图片，ocr 内容为： -->
<p><img src="/blog/blog/assets/posts/cpp17-concurrency/1770025842045-bf9f3414-a54b-4e9c-8296-b3764d3c2f86.jpeg" alt="Linux进程在虚拟内存中的标准内存段布局"></p>
<p>结论非常直接：**同一进程的多个线程，会共享 data&#x2F;BSS&#x2F;heap 等区域。**这些区域里一旦有“可变共享数据”，就必须考虑并发访问的正确性，这就是同步问题最典型的来源。</p>
<p>对比一下进程：不同进程的地址空间天然隔离，一个进程里 <code>counter++</code> 并不会直接把另一个进程的 <code>counter</code> 搞乱。而线程是“默认共享内存”，所以同步问题在多线程下几乎是“必考题”。</p>
<h3 id="1-3-线程越多越好吗？"><a href="#1-3-线程越多越好吗？" class="headerlink" title="1.3 线程越多越好吗？"></a>1.3 线程越多越好吗？</h3><p><strong>线程数和性能之间通常不是线性关系</strong>，线程数增加到某个点以后，吞吐开始下降、延迟开始上升，出现一个“先好后坏”的拐点。</p>
<p>线程并不是“越多越快”的万能解。即使暂时不考虑锁竞争与共享数据争用，仅从系统成本出发，线程数增长也会很快进入<strong>收益递减</strong>，甚至出现吞吐下降、延迟上升的拐点。主要原因可以拆成三类：<strong>创建开销、上下文切换开销、资源占用</strong>。</p>
<h4 id="1-创建开销：线程不是零成本对象"><a href="#1-创建开销：线程不是零成本对象" class="headerlink" title="1) 创建开销：线程不是零成本对象"></a>1) 创建开销：线程不是零成本对象</h4><p>创建线程意味着操作系统需要为新的执行流建立完整的运行环境，典型工作包括：</p>
<ul>
<li>分配并初始化线程栈及其保护页（guard page）</li>
<li>初始化线程上下文（寄存器初始状态、线程入口等）</li>
<li>在内核侧创建&#x2F;注册对应的调度实体，使其能够被调度器管理（例如加入就绪队列、设置调度参数等）</li>
</ul>
<p>这些步骤决定了线程创建并非“轻量级操作”。当系统以“任务来了就新建线程”的方式扩展并发度时，创建成本会直接体现在<strong>启动延迟</strong>与<strong>系统抖动</strong>上，尤其是在短任务场景中，创建&#x2F;销毁线程的开销甚至可能大于任务本身。</p>
<blockquote>
<p><strong>启动延迟</strong>就是：任务来了以后，并不会立刻开始做正事，而是要先把线程“建起来”。创建线程需要准备运行环境（栈、上下文、注册进调度器），这些步骤本身就要时间，所以你会看到“任务开始执行”被推迟。</p>
<p><strong>系统抖动</strong>就是：即使同样的任务、同样的机器，延迟也会忽快忽慢。线程一多，调度与切换更频繁，谁先拿到时间片、缓存是否还热都变得更不稳定，于是耗时波动变大，尾延迟更明显。</p>
</blockquote>
<h4 id="2-上下文切换开销：CPU-时间被消耗在“切换”而非“计算”"><a href="#2-上下文切换开销：CPU-时间被消耗在“切换”而非“计算”" class="headerlink" title="2) 上下文切换开销：CPU 时间被消耗在“切换”而非“计算”"></a>2) 上下文切换开销：CPU 时间被消耗在“切换”而非“计算”</h4><p>当线程数明显超过 CPU 核心数时，多个线程只能依赖时间片轮转共享计算资源。调度的直接结果就是更频繁的上下文切换，其成本主要来自：</p>
<ul>
<li>保存&#x2F;恢复寄存器状态、栈指针、程序计数器等执行上下文</li>
<li>缓存局部性被破坏：切换到另一个线程后，原线程的热数据可能已不在 L1&#x2F;L2 缓存中</li>
<li>TLB 及相关地址转换缓存的有效性下降（尤其在工作集较大、线程频繁切换时更明显）</li>
</ul>
<p>因此你会观察到一个典型现象：线程继续增加时，CPU 使用率可能保持很高，但“有效计算”占比下降，系统时间更多被消耗在调度与恢复现场上，最终体现为吞吐下降、尾延迟变差。</p>
<h4 id="3-资源占用：线程数量首先消耗的是内存与内核管理开销"><a href="#3-资源占用：线程数量首先消耗的是内存与内核管理开销" class="headerlink" title="3) 资源占用：线程数量首先消耗的是内存与内核管理开销"></a>3) 资源占用：线程数量首先消耗的是内存与内核管理开销</h4><p>每个线程都至少需要一块独立的<strong>线程栈</strong>和相应的内核管理开销。线程数一多，内存压力会上来，系统也要维护更多调度对象。结果就是：线程开到一定规模后，不是性能更好，而是更容易出现资源紧张、创建失败或整体变慢。  </p>
<h4 id="4-结论：线程数不是越多越好，而是要“够用且可控”"><a href="#4-结论：线程数不是越多越好，而是要“够用且可控”" class="headerlink" title="4) 结论：线程数不是越多越好，而是要“够用且可控”"></a>4) 结论：线程数不是越多越好，而是要“够用且可控”</h4><p>所以，线程数也存在一个非常现实的上限：<strong>系统内存与调度能力</strong>。</p>
<p><strong>线程数的上限，往往先被资源（尤其是线程栈&#x2F;内存与调度开销）卡住，而不是被“任务是否够多”卡住。</strong></p>
<blockquote>
<ul>
<li><strong>CPU 密集型任务</strong>：线程数通常接近 CPU 核心数（或略多一点点）更合理。<code>std::thread::hardware_concurrency()</code> 可以作为一个粗略参考值。</li>
<li><strong>IO 密集型任务</strong>：确实可以开得比核心数多，但仍然会遇到“线程栈占用 + 调度切换”导致的收益递减。</li>
<li><strong>工程上更常见的做法是线程池</strong>：让线程数保持稳定可控，避免“每来一个任务就创建一个线程”的资源失控问题。后面讲生产者-消费者时，你会发现它本质上就在解决同一个主题：<strong>让任务排队，而不是让线程无限增长</strong>。</li>
</ul>
</blockquote>
<hr>
<h2 id="并发为什么会错：竞态条件、数据竞争、原子性与“多线程-1”直观演示"><a href="#并发为什么会错：竞态条件、数据竞争、原子性与“多线程-1”直观演示" class="headerlink" title="并发为什么会错：竞态条件、数据竞争、原子性与“多线程 +1”直观演示"></a>并发为什么会错：竞态条件、数据竞争、原子性与“多线程 +1”直观演示</h2><p>并发代码之所以“容易写错”，本质原因并不神秘：<strong>多条执行流的指令会以各种不可预测的顺序交错（interleaving）</strong>。一旦这些交错发生在“共享数据的读写”上，就可能导致：同样的输入、同样的代码，每次运行输出都不一样，甚至在 C++ 里直接进入未定义行为。这种“输出随调度时序变化”的现象被称为 <em>indeterminate</em>（不确定性），这种不确定性往往来自于未被保护的共享资源访问。</p>
<h3 id="2-1-Race-Condition-vs-Data-Race"><a href="#2-1-Race-Condition-vs-Data-Race" class="headerlink" title="2.1 Race Condition vs Data Race"></a>2.1 Race Condition vs Data Race</h3><p>先把两个经常被混用的词分清楚。</p>
<p><strong>Race Condition（竞态条件）</strong>：这是操作系统&#x2F;并发编程里更“泛化”的概念。它强调的是：<strong>结果依赖执行时序</strong>。当多个线程“差不多同时”进入某段访问共享资源的代码（临界区），程序结果就可能变得不可预测。OSTEP 在并发导论里就用“race condition（或更具体地说 data race）”来描述这种时序依赖导致的不确定结果。</p>
<p>注意：在系统教材里，race condition &#x2F; data race 有时会被放在同一语境里讲；但在 C++ 语言层面，<strong>data race</strong>有非常严格的定义。</p>
<p><strong>Data Race（数据竞争，C++ 语义）</strong>：在 C++11 及之后的内存模型里，data race 是一个更“硬”的术语：当两个线程对同一内存位置发生冲突访问（至少一个是写），且它们之间没有建立 happens-before 关系（例如通过互斥锁同步），<strong>程序行为就是未定义（Undefined Behavior, UB）</strong>。cppreference 明确写到：一旦发生 data race，程序行为未定义，并给出了类似 <code>cnt++</code> 的例子。</p>
<p><strong>容易混淆的点（Tip）</strong><br>“跑起来没错”并不能证明没有 data race。因为 UB 的可怕之处在于：编译器和运行时不再需要对你的程序做任何保证，某次优化、某个平台、某个负载下才爆，是常见现象。</p>
<h3 id="2-2-原子性（Atomicity）与临界区（Critical-Section）"><a href="#2-2-原子性（Atomicity）与临界区（Critical-Section）" class="headerlink" title="2.2 原子性（Atomicity）与临界区（Critical Section）"></a>2.2 原子性（Atomicity）与临界区（Critical Section）</h3><p>并发错误经常出现在一种场景里：<strong>一段逻辑看起来像“一个操作”，实际上是多个步骤</strong>。例如 <code>counter++</code>，你在语义上想表达“加一”，但在机器层面通常会拆成三步：<strong>读（load）→ 改（add）→ 写（store）</strong>。</p>
<p>这类“必须整体不可分割”的代码片段，就是我们在并发里反复提到的 <strong>临界区（critical section）</strong>：它访问共享变量或共享资源，不能被多个线程同时执行。OSTEP 给出的定义非常直接：临界区是一段访问共享资源的代码，必须确保同一时间最多一个线程进入。</p>
<p>进一步地，我们真正想要的是让临界区“看起来像一条原子指令一样执行”（也就是把一串指令当作不可被并发打断的整体）。OSTEP 在讲锁的基本思想时也强调：加锁的目标就是让临界区“仿佛作为一条单独的原子指令执行”。</p>
<h3 id="2-3-示例：多线程下的自增操作为什么线程不安全"><a href="#2-3-示例：多线程下的自增操作为什么线程不安全" class="headerlink" title="2.3 示例：多线程下的自增操作为什么线程不安全"></a>2.3 示例：多线程下的自增操作为什么线程不安全</h3><p>现在用最经典的例子把“交错执行”带来的问题落地：多个线程同时对一个共享计数器做 <code>++</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>; <span class="comment">// 共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_one_million</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1&#x27;000&#x27;000</span>; ++i) &#123;</span><br><span class="line">        ++a; <span class="comment">// data race: 未同步的并发写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(add_one_million)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(add_one_million)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;expected: 2000000\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;actual:   &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/blog/blog/assets/posts/cpp17-concurrency/1770034005590-32a1b126-4679-457c-b280-6dbc026193b6.png" alt="程序的运行结果，结果不符合预期且每次运行结果各不相同"></p>
<p>直觉上，如果 2 个线程各自执行 100 万次 <code>++</code>，结果应该是 200 万。但你把这段代码放到多线程里跑，常常会发现：最终结果<strong>小于预期</strong>，而且每次运行还可能不一样。</p>
<p>关键原因在于：<code>++</code>** 看起来是“一步”，其实通常可以拆成三步完成**：</p>
<ol>
<li><strong>读出来</strong>：把变量当前的值从内存读到 CPU 的寄存器里</li>
<li><strong>加一</strong>：在寄存器里把这个值 +1</li>
<li><strong>写回去</strong>：把加完后的结果再写回内存中的变量</li>
</ol>
<p>单线程时，这三步总是按顺序完成，没问题；但在多线程时，两个线程可能会在这三步中<strong>交错执行</strong>。一旦发生“交错”，就可能出现这种情况：</p>
<ul>
<li>线程 1 先读到 <code>a = 100</code>（还没来得及写回）</li>
<li>线程 2 也读到 <code>a = 100</code></li>
<li>线程 1 加一写回 <code>a = 101</code></li>
<li>线程 2 也加一写回 <code>a = 101</code></li>
</ul>
<p>你看，两个线程都做了“加一”，但结果只从 100 变成了 101，本该变成 102 的那一次增量就<strong>丢了</strong>。这就是为什么多线程下 <code>++</code> 会出现“算少了”的现象。</p>
<p><img src="/blog/blog/assets/posts/cpp17-concurrency/1770033787247-c732de96-8462-4601-af4e-8910ffd9cbdd.png" alt="两张线程并发执行 a++ 操作时，因该操作拆分为读、改、写三步非原子操作，二者均读取主内存初始值 0 并本地加 1 后写回，最终主内存值为 1 而非预期的 2"></p>
<blockquote>
<p>更关键的是：在 C++ 的语义里，这种写法不仅“可能算错”，而是<strong>直接构成 data race，行为未定义</strong>。cppreference 的多线程与数据竞争章节甚至把这个例子作为典型反例，并明确标注为 undefined behavior；同时也展示了把 <code>int</code> 换成 <code>std::atomic&lt;int&gt;</code> 后就变为良定义行为。</p>
</blockquote>
<blockquote>
<p>这不是概率问题。并发下指令交错是常态，你只能控制交错发生时是否仍然正确，而不能指望它别交错。这种现象被称为 <em>indeterminate</em>：输出随线程运行时序变化而变化。</p>
</blockquote>
<h3 id="2-4-从“线程安全”自然过渡到“可重入”（避免引入突兀）"><a href="#2-4-从“线程安全”自然过渡到“可重入”（避免引入突兀）" class="headerlink" title="2.4 从“线程安全”自然过渡到“可重入”（避免引入突兀）"></a>2.4 从“线程安全”自然过渡到“可重入”（避免引入突兀）</h3><p>到这里，你基本已经能形成一个清晰的判断标准：所谓<strong>线程安全</strong>，核心就是“并发调用时仍然正确”，通常意味着你要么避免共享可变状态，要么用同步手段建立正确的执行关系。</p>
<p>而**可重入（re-entrant）**经常被拿来和线程安全一起出现，但它关注的是另一个维度：<strong>某个操作在“尚未完成时”又被再次进入，是否仍然正确</strong>。</p>
<p>比如：同一个函数正在执行过程中（可能因为中断、信号处理、回调、递归等原因）再次进入这个函数，如果它内部依赖某些隐藏的可变共享状态（静态缓冲区、全局临时变量等），就可能出问题。</p>
<p>二者的区分很清晰：线程安全是“多线程同时调用也安全”；可重入是“在一次调用尚未完成时再次调用也安全”，因此可重入通常是更强的要求。<br>另外，POSIX 的白皮书也给出了“reentrant function”的规范性表述（强调多线程交错调用时效果应等价于某种串行顺序）。</p>
<h3 id="2-5-活性问题：死锁-活锁-饥饿"><a href="#2-5-活性问题：死锁-活锁-饥饿" class="headerlink" title="2.5 活性问题：死锁&#x2F;活锁&#x2F;饥饿"></a>2.5 活性问题：死锁&#x2F;活锁&#x2F;饥饿</h3><p>并发还有一类更隐蔽的风险：<strong>程序不再前进（lack of progress）</strong>。典型包括：</p>
<ul>
<li><strong>Deadlock（死锁）</strong>：所有线程都卡住了，互相等待资源，谁也无法继续。</li>
</ul>
<blockquote>
<ul>
<li>CS537 的讲义用一句话概括：一种策略让所有线程都“stuck”，无人能前进。</li>
<li>另一个讲义进一步强调了死锁的本质：每个实体都在等待别人持有的资源，形成等待环。</li>
<li><font style="color:rgb(0, 0, 0);">死锁的发生必须同时满足四个必要条件：互斥条件、请求与保持条件、不剥夺条件和循环等待条件。</font></li>
</ul>
</blockquote>
<ul>
<li><strong>Starvation（饥饿）</strong>：不是所有线程都卡住，而是<strong>某个线程可能无限期等不到运行或资源</strong>。</li>
</ul>
<blockquote>
<p>CS537 讲义把它描述为：策略导致某些线程在某些情况下长期不执行。</p>
</blockquote>
<p><img src="/blog/blog/assets/posts/cpp17-concurrency/1770034862410-a825e54c-9a56-4f1a-9075-c29a447d284f.webp" alt="当低优先级的新进程持续涌入时，原本优先级更高（优先级 5）的进程会因一直无法获得 CPU 执行权而陷入长期等待"></p>
<ul>
<li><strong>Livelock（活锁）</strong>：所有线程都在“忙”，但一直在做无效动作，仍然没有进展。</li>
</ul>
<blockquote>
<p>CS537 讲义的表述非常直观：大家一直做事，但永远无法取得进展。</p>
</blockquote>
<p><img src="/blog/blog/assets/posts/cpp17-concurrency/1770034915381-3617d761-c5ed-4a41-a822-b04ade440f57.jpeg" alt="两个进程因进程表已满导致fork()调用失败后，不断重复重试却始终无法推进，处于看似忙碌但没有实际进展的状态"></p>
<hr>
<h2 id="线程互斥（Mutual-Exclusion）"><a href="#线程互斥（Mutual-Exclusion）" class="headerlink" title="线程互斥（Mutual Exclusion）"></a>线程互斥（Mutual Exclusion）</h2><h3 id="原子操作（Atomic）：什么时候“无需锁”，什么时候“必须锁”"><a href="#原子操作（Atomic）：什么时候“无需锁”，什么时候“必须锁”" class="headerlink" title="原子操作（Atomic）：什么时候“无需锁”，什么时候“必须锁”"></a>原子操作（Atomic）：什么时候“无需锁”，什么时候“必须锁”</h3><p>在上一章你已经看到：对普通 <code>int</code> 做并发 <code>++</code>，不仅“可能算错”，在 C++ 语义里更是 <strong>data race → 未定义行为</strong>。这一章我们把视角切到 <code>std::atomic</code>：它能把哪些问题变成“良定义”，又在哪些地方<strong>绝对不该</strong>用 atomic 代替锁。</p>
<h4 id="std-atomic-的基本语义（C-17）"><a href="#std-atomic-的基本语义（C-17）" class="headerlink" title="std::atomic 的基本语义（C++17）"></a><code>std::atomic</code> 的基本语义（C++17）</h4><p><code>std::atomic&lt;T&gt;</code> 的核心承诺很简单：<strong>对同一个原子对象的并发访问，语言层面给出清晰语义</strong>。你最常用的是两类操作：</p>
<ul>
<li><strong>原子读&#x2F;写</strong>：<code>load()</code> &#x2F; <code>store()</code></li>
<li><strong>原子读-改-写（RMW, read-modify-write）</strong>：把“读旧值 + 计算新值 + 写回”合成一个不可分割的整体，例如 <code>fetch_add</code>（以及常见的 <code>++counter</code>）。在文档里，<code>fetch_add</code> 被明确标注为 read-modify-write 操作。</li>
</ul>
<p>这就是为什么把共享变量从 <code>int</code> 换成 <code>std::atomic&lt;int&gt;</code> 后，多线程下的累加能稳定得到正确结果：你不再是在并发环境里“拆成三步地更新”，而是在做<strong>语言定义的原子 RMW</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_one_million</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1&#x27;000&#x27;000</span>; ++i) &#123;</span><br><span class="line">        ++a; <span class="comment">// data race: 未同步的并发写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(add_one_million)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(add_one_million)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;expected: 2000000\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;actual:   &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/blog/blog/assets/posts/cpp17-concurrency/1770034228982-a1df33be-c6bc-4531-a006-eff857fc0018.png" alt="更换为原子操作后，结果变为正确的"></p>
<blockquote>
<p><strong>atomic 解决的是“单变量原子性”，不是“任意逻辑一致性”</strong><br>把一个变量做成 atomic，只能保证这个变量的每次读写&#x2F;更新是良定义的；如果你的正确性依赖“多个共享状态一起保持某种关系”，那就已经超出 atomic 的能力边界。</p>
</blockquote>
<p>在某些设置下（比如开启优化、跑在多核 CPU 上），<strong>编译器和 CPU 可能会为了性能，把原子操作及其周围的普通读写，在“对外可见的顺序”上做调整</strong>。你写代码时看到的是“先 A 再 B”，但另一个线程观察到的效果（例如被编译器优化了后），可能更像“B 先发生、A 后发生”。这类现象通常就用一个词概括：<strong>指令重排序</strong>。</p>
<p>它会造成非常经典、也最容易理解的并发 bug：<strong>“信号先到，数据后到”</strong>。例如你在线程 A 里写：</p>
<blockquote>
<ul>
<li>先把数据写好（普通变量）</li>
<li>再把 <code>ready = true</code>（原子变量）当作“通知”</li>
</ul>
</blockquote>
<p>直觉上，线程 B 只要看到 <code>ready == true</code>，就应该能读到最新数据；但如果没有足够的约束，B 可能出现：看到了 ready&#x3D;true，却还没看到数据更新的情况。这里不是说代码“乱执行”，而是说<strong>跨线程观察时，写入被看见的先后顺序可能不符合你的直觉</strong>。</p>
<p>为了解决这种“顺序&#x2F;可见性”问题，C++ 给原子操作设计了一个参数：<code>std::memory_order</code>，用来规定<strong>原子操作周围的内存访问应该按多强的规则排序</strong>。</p>
<p>而你不显式写 <code>memory_order</code> 时，标准库的默认行为是：<strong>按顺序一致（<code>memory_order_seq_cst</code>）来处理</strong>。你可以把它理解为“最保守、最不容易写错、也最容易推理”的默认规则：让不同线程看到的原子操作顺序尽量一致，从而降低“信号先到、数据后到”这种反直觉现象。</p>
<p>（像 <code>fetch_add</code> 这类原子 RMW 操作也支持指定 <code>order</code>，默认不写就走上述默认规则。）</p>
<h4 id="CAS（Compare-And-Swap-Exchange）"><a href="#CAS（Compare-And-Swap-Exchange）" class="headerlink" title="CAS（Compare-And-Swap&#x2F;Exchange）"></a>CAS（Compare-And-Swap&#x2F;Exchange）</h4><p>前面我们用 <code>fetch_add</code> 修复了多线程自增问题，这很好理解：“加一”这种规则太常见了，所以标准库直接给了现成接口。但我们很快会遇到下一类需求：</p>
<blockquote>
<p>我不想“加一”，我想按自己的规则更新：例如“把值更新成更大的那个”“只有满足某个条件才更新”“基于旧值算出新值再写回”。标准库没给现成接口怎么办？</p>
</blockquote>
<h5 id="CAS-在干什么？先从“并发下值会变”说起"><a href="#CAS-在干什么？先从“并发下值会变”说起" class="headerlink" title="CAS 在干什么？先从“并发下值会变”说起"></a>CAS 在干什么？先从“并发下值会变”说起</h5><p>在并发环境里，你常常会遇到一个事实：<strong>你刚读到的值，下一秒可能就被别的线程改了。</strong></p>
<p>所以问题变成：我能不能这样做——</p>
<blockquote>
<ul>
<li>我先读到一个值 <code>expected</code></li>
<li>我基于它计算出一个新值 <code>desired</code></li>
<li>但在写回之前，我希望确认：<strong>“它还是不是我刚才看到的那个值？”</strong></li>
</ul>
<p>如果不是，那说明有人插队修改过，我就不能盲目写回。</p>
</blockquote>
<p>CAS 就是用来解决这一点的。它的意思可以用一句话说清楚：**“如果当前值还等于 <code>expected</code>，就把它改成 <code>desired</code>；否则不改，并把实际值告诉我。”**在 C++ 里，这个操作叫 <code>compare_exchange_weak/compare_exchange_strong</code>（compare-and-exchange）。</p>
<h5 id="为什么-CAS-总是和“循环”绑定？"><a href="#为什么-CAS-总是和“循环”绑定？" class="headerlink" title="为什么 CAS 总是和“循环”绑定？"></a>为什么 CAS 总是和“循环”绑定？</h5><p>因为 CAS 的失败并不是异常情况，反而是并发下的常态：</p>
<blockquote>
<ul>
<li>你读到 <code>expected</code></li>
<li>别的线程抢先把值改了</li>
<li>你 CAS 失败</li>
<li><strong>失败时 <code>expected</code> 会被更新成“当前真实值”</strong>，你再基于新值计算、继续尝试</li>
</ul>
</blockquote>
<p>所以 CAS 的标准用法几乎都是：<strong>读-算-尝试（失败就重试）</strong>。</p>
<blockquote>
<p><code>compare_exchange_weak</code> 允许一种现象：即使当前值等于 <code>expected</code>，它也可能返回失败（spurious failure）。所以 <code>weak</code> 版本通常就是写在循环里重试，而且在一些平台上它可能更高效。我们可以把它当成一条写法规则：<strong>weak 默认就要放在循环里；strong 用在你真的希望“相等就尽量成功”的地方。</strong></p>
</blockquote>
<h5 id="示例：用-CAS-实现-“原子更新最大值”"><a href="#示例：用-CAS-实现-“原子更新最大值”" class="headerlink" title="示例：用 CAS 实现 “原子更新最大值”"></a>示例：用 CAS 实现 “原子更新最大值”</h5><p>多个线程同时更新一个共享变量 <code>a</code>，希望它最终等于出现过的最大值（<code>a = max(a, v)</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_update_max</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = a.<span class="built_in">load</span>();                <span class="comment">// 先读一个旧值</span></span><br><span class="line">    <span class="keyword">while</span> (expected &lt; v &amp;&amp;                 <span class="comment">// 只有 v 更大才需要更新</span></span><br><span class="line">        !a.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">        expected, v)) &#123;             <span class="comment">// 失败时 expected 会被写成“当前真实值”</span></span><br><span class="line">        <span class="comment">// 什么也不用做，继续循环即可：</span></span><br><span class="line">        <span class="comment">// 1) expected 已被更新为最新值</span></span><br><span class="line">        <span class="comment">// 2) 重新判断 expected &lt; v</span></span><br><span class="line">        <span class="comment">// 3) 再尝试 CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; ts;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        ts.<span class="built_in">emplace_back</span>([&amp;a, i] &#123;</span><br><span class="line">            <span class="comment">// 每个线程尝试把 a 更新成一个不同的值</span></span><br><span class="line">            <span class="built_in">atomic_update_max</span>(a, i * <span class="number">10</span> + <span class="number">7</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : ts) t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;final a = &quot;</span> &lt;&lt; a.<span class="built_in">load</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 期望是最大值：77</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码最重要的两点是：</p>
<ol>
<li><strong>CAS 保证“检查 + 更新”是一个整体</strong>：只有当 <code>a</code> 仍等于 <code>expected</code> 时才写入新值，否则就失败。</li>
<li><strong>失败不是坏事</strong>：失败时 <code>expected</code> 会自动变成最新值，让你能基于最新状态再算一次、再试一次。</li>
</ol>
<h4 id="atomic-的边界：为什么“复合不变量”仍需要锁"><a href="#atomic-的边界：为什么“复合不变量”仍需要锁" class="headerlink" title="atomic 的边界：为什么“复合不变量”仍需要锁"></a>atomic 的边界：为什么“复合不变量”仍需要锁</h4><p><code>std::atomic</code> 很容易被用过头：把 <code>x</code>、<code>y</code>、<code>state</code>、<code>size</code> 统统改成 atomic，然后下意识觉得“那整体就线程安全了”。问题在于，atomic 提供的是<strong>单个变量的原子性</strong>，而此时我们真正想要的往往是<strong>多个变量之间的整体一致性</strong>。</p>
<p>先从“并发下最容易发生的事”说起：你的一次更新如果要改两个变量，哪怕每次 <code>store()</code> 都是原子的，这两次写入之间仍然存在一个窗口。在这个窗口里，另一个线程完全可能插进来读数据，于是它就会读到一个“半更新”的中间态。</p>
<p>举个最简单的例子：你希望永远满足 <code>x &lt; y</code>，写线程要做的是“同时调整 x 和 y”。但现实是它只能先改一个，再改另一个；读线程只要恰好夹在中间，就能看到临时违反不变量的组合，比如 <code>x</code> 已经变大，而 <code>y</code> 还没来得及跟上。这里并不是 atomic “失效”，而是：<strong>你需要的是一次事务式更新（要么都变，要么都不变），atomic 给不了这种跨变量的一致性快照</strong>。</p>
<p><img src="/blog/blog/assets/posts/cpp17-concurrency/1770037071430-706af7df-bc92-4d00-9c78-95a33766dfb1.png" alt="跨变量更新引发的不变量破坏问题"></p>
<p>更进一步，在多核系统里，如果你对多个变量进行读写而没有足够的同步&#x2F;约束，不同线程观察到“值变化的顺序”甚至可能不一致：一个线程看到 <code>x</code> 先变，另一个线程看到 <code>y</code> 先变。cppreference 对 <code>memory_order</code> 的说明就明确提到：当多个线程同时读写多个变量时，一个线程可能观察到的变化顺序不同于另一个线程写入顺序，甚至不同读线程之间观察到的顺序也可能不同。</p>
<p>这句话的直观含义是：当你在做“复合状态更新”时，如果没有把它变成一个整体的同步单元，读者看到的世界可能是“拼接出来的”。</p>
<p>所以一旦我们的正确性条件是跨多个共享状态的，例如：</p>
<blockquote>
<ul>
<li><code>x &lt; y</code> 必须始终成立</li>
<li>一个对象的多个字段必须同时更新才算“进入新状态”</li>
<li><code>map</code> 与旁路索引必须一致</li>
</ul>
</blockquote>
<p>那么单靠 atomic 往往会把你带到“局部都很原子，但整体仍可能乱”的局面：每个字段单独读写都没 data race，可读到的组合却可能不一致。</p>
<blockquote>
<p>atomic 也不保证一定“无锁”。cppreference 明确写到：除了 <code>std::atomic_flag</code> 外，其它 atomic 类型<strong>允许用 mutex 或其它锁机制实现</strong>；是否 lock-free 需要看 <code>is_lock_free()</code>&#x2F;<code>is_always_lock_free</code> 的结果。</p>
</blockquote>
<h4 id="3-3-性能陷阱：伪共享（False-Sharing）"><a href="#3-3-性能陷阱：伪共享（False-Sharing）" class="headerlink" title="3.3 性能陷阱：伪共享（False Sharing）"></a>3.3 性能陷阱：伪共享（False Sharing）</h4><blockquote>
<p><strong>读者提示</strong>：理解下面的“伪共享（false sharing）”需要你先知道三件事：<br>1）CPU 缓存以 <strong>cache line</strong> 为最小管理单位；<br>2）多核通过 <strong>缓存一致性协议</strong>维护 cache line 的共享与失效；<br>3）多数 CPU 采用 <strong>write-back&#x2F;写缓冲</strong>，写入需要通过一致性协议传播到其他核心。<br>伪共享的本质就是：两个线程改的是不同变量，但它们落在同一条 cache line 上，导致一致性协议把整条 cache line 当成“共享热点”来回同步，从而白白产生开销。  </p>
</blockquote>
<blockquote>
<p><font style="color:rgb(32, 33, 34);">In </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_science"><font style="color:rgb(51, 102, 204);">computer science</font></a><font style="color:rgb(32, 33, 34);">, </font><strong><font style="color:rgb(32, 33, 34);">false sharing</font></strong><font style="color:rgb(32, 33, 34);"> is a performance-degrading usage pattern that can arise in systems with distributed, </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cache_coherence"><font style="color:rgb(51, 102, 204);">coherent caches</font></a><font style="color:rgb(32, 33, 34);"> at the size of the smallest resource block managed by the caching mechanism. When a system participant attempts to periodically access data that is not being altered by another party, but that data shares a cache block with data that </font><em><font style="color:rgb(32, 33, 34);">is</font></em><font style="color:rgb(32, 33, 34);"> being altered, the caching protocol may force the first participant to reload the whole cache block despite a lack of logical necessity. The caching system is unaware of activity within this block and forces the first participant to bear the caching system overhead required by true shared access of a resource.</font></p>
<p><font style="color:rgb(32, 33, 34);">By far the most common usage of this term is in modern </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiprocessor"><font style="color:rgb(51, 102, 204);">multiprocessor</font></a><font style="color:rgb(32, 33, 34);"> </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CPU_cache"><font style="color:rgb(51, 102, 204);">CPU caches</font></a><font style="color:rgb(32, 33, 34);">, where </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Random_access_memory"><font style="color:rgb(51, 102, 204);">memory</font></a><font style="color:rgb(32, 33, 34);"> is cached in </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cache_line"><font style="color:rgb(51, 102, 204);">lines</font></a><font style="color:rgb(32, 33, 34);"> of some small </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Power_of_two"><font style="color:rgb(51, 102, 204);">power of two</font></a><font style="color:rgb(32, 33, 34);"> </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Word_(data_type)"><font style="color:rgb(51, 102, 204);">word</font></a><font style="color:rgb(32, 33, 34);"> size (e.g., 64 </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_structure_alignment"><font style="color:rgb(51, 102, 204);">aligned</font></a><font style="color:rgb(32, 33, 34);">, contiguous </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Byte"><font style="color:rgb(51, 102, 204);">bytes</font></a><font style="color:rgb(32, 33, 34);">). If two processors operate on independent data in the same </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_address"><font style="color:rgb(51, 102, 204);">memory address</font></a><font style="color:rgb(32, 33, 34);"> region storable in a single line, the cache coherency mechanisms in the system may force the whole line across the </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bus_(computing)"><font style="color:rgb(51, 102, 204);">bus</font></a><font style="color:rgb(32, 33, 34);"> or interconnect with every data write, forcing memory stalls in addition to wasting system </font><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bandwidth_(computing)"><font style="color:rgb(51, 102, 204);">bandwidth</font></a><font style="color:rgb(32, 33, 34);">. In some cases, the elimination of false sharing can result in order-of-magnitude performance improvements.False sharing is an inherent artifact of automatically synchronized cache protocols and can also exist in environments such as distributed file systems or databases, but current prevalence is limited to RAM caches.</font></p>
</blockquote>
<p>另一个常见误解是：把锁换成 atomic，就一定更快。并发下经常出现相反情况：<strong>atomic 写得越频繁，越可能越慢</strong>。</p>
<p>原因往往不在“原子指令本身”，而在缓存一致性：当多个线程频繁写同一个 cache line 上的数据时，该 cache line 会在不同 CPU 核之间反复失效&#x2F;同步，吞吐下降、延迟抖动。这种“两个线程写的是不同变量，但它们恰好落在同一条 cache line 上，于是互相拖累”的现象，就叫 <strong>伪共享（false sharing）</strong>。</p>
<hr>
<h3 id="std-mutex-与为什么不要手写-lock-unlock"><a href="#std-mutex-与为什么不要手写-lock-unlock" class="headerlink" title="std::mutex 与为什么不要手写 lock()/unlock()"></a><code>std::mutex</code> 与为什么不要手写 <code>lock()/unlock()</code></h3><blockquote>
<p>在上一 节我们已经见过“共享变量并发写会出事”。接下来我们需要一个更工程化的工具：把“临界区”围起来，让同一时刻只有一个线程能进入。C++ 标准库提供的核心原语是 <code>std::mutex</code>，以及一组围绕 RAII 设计的锁管理器（<code>lock_guard/unique_lock/scoped_lock/...</code>）。</p>
</blockquote>
<p><code>std::mutex</code> 的职责很单纯：<strong>保护共享数据，避免被多个线程同时访问</strong>。问题在于：如果我们手写 <code>lock()</code> &#x2F; <code>unlock()</code>，一旦代码中途 <code>return</code>、<code>throw</code>、或未来某次维护时忘了写 <code>unlock()</code>，就会把互斥量“永远锁住”，其他线程会一直等下去。</p>
<p>下面这段对比代码展示了这个风险：反例里我们故意 <code>throw</code>，然后用 <code>try_lock()</code> 观察互斥量是否还被锁着（避免程序真的卡死）；正例用 RAII 的 <code>std::lock_guard</code>，即使抛异常也会在析构时自动释放。<code>lock_guard</code> 的语义是“构造时加锁、离开作用域析构时解锁”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex g_m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    g_m.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;oops&quot;</span>); <span class="comment">// 永远到不了 unlock</span></span><br><span class="line">    g_m.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">good</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(g_m)</span></span>; <span class="comment">// RAII：作用域结束必解锁</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;oops&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 反例：手写 lock/unlock，异常后锁被“遗留”</span></span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="built_in">bad</span>(); &#125; <span class="built_in">catch</span> (...) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (g_m.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[bad] mutex is NOT locked (unexpected)\n&quot;</span>;</span><br><span class="line">        g_m.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[bad] mutex is still locked -&gt; other threads would block\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 为了不影响后续演示，这里把它解开</span></span><br><span class="line">        g_m.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正例：lock_guard，异常后锁仍会被释放</span></span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="built_in">good</span>(); &#125; <span class="built_in">catch</span> (...) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (g_m.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[good] mutex is unlocked (expected)\n&quot;</span>;</span><br><span class="line">        g_m.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[good] mutex is still locked (unexpected)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以把锁理解为“锁住共享数据的访问权”，而不是“锁住某段代码”。工程上更推荐把 <code>mutex</code> 和它保护的数据一起封装进类，减少“忘记加锁&#x2F;锁错对象”的概率。</p>
</blockquote>
<h3 id="std-lock-guard：默认首选"><a href="#std-lock-guard：默认首选" class="headerlink" title="std::lock_guard：默认首选"></a><code>std::lock_guard</code>：默认首选</h3><p><code>std::lock_guard</code> 是最轻量的 RAII 锁管理器：构造时尝试获取互斥量所有权，离开作用域就释放。它不可拷贝，也不提供中途解锁等复杂能力，所以简单、稳定、开销低。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>         <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>          <span class="comment">// std::mutex, std::lock_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span>      <span class="comment">// std::logic_error</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_even</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x%<span class="number">2</span>==<span class="number">0</span>) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; is even\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">throw</span> (std::<span class="built_in">logic_error</span>(<span class="string">&quot;not even&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_thread_id</span> <span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span> <span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="built_in">print_even</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::logic_error&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[exception caught]\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread threads[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// spawn 10 threads:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(print_thread_id,i<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-unique-lock：为条件变量与更复杂流程准备"><a href="#std-unique-lock：为条件变量与更复杂流程准备" class="headerlink" title="std::unique_lock：为条件变量与更复杂流程准备"></a><code>std::unique_lock</code>：为条件变量与更复杂流程准备</h3><p><code>std::unique_lock</code> 的定位是“更通用的锁所有权管理器”：它支持延迟加锁、<code>try_lock</code>、中途 <code>unlock</code> &#x2F; 重新 <code>lock</code>，还可以移动（transfer ownership）。</p>
<p>下面这段代码展示两个常用模式：延迟加锁（<code>defer_lock</code>）和缩短持锁时间（中途 <code>unlock</code> 把重活放到锁外做）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m, std::defer_lock)</span></span>; <span class="comment">// 先不锁</span></span><br><span class="line">    <span class="comment">// ...做一些不需要锁的准备工作</span></span><br><span class="line">    lk.<span class="built_in">lock</span>();   <span class="comment">// 真正进入临界区</span></span><br><span class="line">    <span class="comment">// 修改共享数据（需要锁保护）</span></span><br><span class="line">    lk.<span class="built_in">unlock</span>(); <span class="comment">// 尽早放锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重活放在锁外：IO、计算、回调等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多把锁的标准解：std-scoped-lock-std-lock"><a href="#多把锁的标准解：std-scoped-lock-std-lock" class="headerlink" title="多把锁的标准解：std::scoped_lock &#x2F; std::lock"></a>多把锁的标准解：<code>std::scoped_lock</code> &#x2F; <code>std::lock</code></h3><p>多把锁最常见的风险是死锁：线程 A 先锁 <code>m1</code> 再锁 <code>m2</code>，线程 B 反过来先锁 <code>m2</code> 再锁 <code>m1</code>，两边互相等待就卡住。C++17 推荐的写法是：要么统一顺序，要么一次性锁多把。</p>
<p><code>std::scoped_lock</code> 是 C++17 引入的 RAII 包装器，支持“持有 0 或多把互斥量”。<code>std::lock</code> 是更底层的“一次性锁多把”的函数，cppreference 也明确提示：<code>scoped_lock</code> 是它的 RAII 包装器，一般更推荐。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    <span class="type">int</span> balance&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(Account&amp; from, Account&amp; to, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lk</span><span class="params">(from.m, to.m)</span></span>; <span class="comment">// C++17：一次性锁多把</span></span><br><span class="line">    from.balance -= amount;</span><br><span class="line">    to.balance += amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transfer2</span><span class="params">(Account&amp; from, Account&amp; to, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">l1</span><span class="params">(from.m, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">l2</span><span class="params">(to.m, std::defer_lock)</span></span>;</span><br><span class="line">    std::<span class="built_in">lock</span>(l1, l2); <span class="comment">// 一次性获取两把锁</span></span><br><span class="line">    from.balance -= amount;</span><br><span class="line">    to.balance += amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多锁场景我们只保留两条纪律：统一顺序，或使用 <code>scoped_lock/std::lock</code>。不要随手写“先锁 A 再锁 B”的不一致逻辑。</p>
</blockquote>
<h3 id="读多写少：std-shared-mutex-std-shared-lock"><a href="#读多写少：std-shared-mutex-std-shared-lock" class="headerlink" title="读多写少：std::shared_mutex + std::shared_lock"></a>读多写少：<code>std::shared_mutex</code> + <code>std::shared_lock</code></h3><p>当共享数据“读远多于写”时，普通 <code>mutex</code> 会把读也串行化，浪费并发性。C++17 提供 <code>std::shared_mutex</code>：它支持两种模式：</p>
<blockquote>
<ul>
<li>共享（shared）：多个线程可同时持有（读锁）</li>
</ul>
<p>独占（exclusive）：同一时刻只能一个线程持有（写锁）</p>
</blockquote>
<p><code>std::shared_lock</code> 用于管理共享锁；而独占锁仍然用 <code>std::unique_lock&lt;shared_mutex&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeMap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> k)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lk</span><span class="params">(mu_)</span></span>; <span class="comment">// 读：共享锁</span></span><br><span class="line">    <span class="keyword">auto</span> it = m_.<span class="built_in">find</span>(k);</span><br><span class="line">    <span class="keyword">return</span> it == m_.<span class="built_in">end</span>() ? <span class="number">0</span> : it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lk</span><span class="params">(mu_)</span></span>; <span class="comment">// 写：独占锁</span></span><br><span class="line">    m_[k] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">mutable</span> std::shared_mutex mu_;</span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配图建议（读多写少示意图）<br>画三个读者同时持有 shared_lock（绿色），一个写者请求独占锁（红色），并标注“写者需等待读者全部释放”。<code>shared_mutex::lock()</code> 的说明里也强调：当已有共享锁&#x2F;独占锁存在时，独占加锁会阻塞。</p>
<blockquote>
<p>公平性与“写者是否可能饥饿”依实现与策略而定，不要默认“写一定很快拿到锁”。</p>
</blockquote>
<hr>
<h2 id="线程同步（Synchronization）"><a href="#线程同步（Synchronization）" class="headerlink" title="线程同步（Synchronization）"></a>线程同步（Synchronization）</h2><h3 id="条件变量：从忙等到阻塞等待"><a href="#条件变量：从忙等到阻塞等待" class="headerlink" title="条件变量：从忙等到阻塞等待"></a>条件变量：从忙等到阻塞等待</h3><h4 id="为什么需要-std-condition-variable"><a href="#为什么需要-std-condition-variable" class="headerlink" title="为什么需要 std::condition_variable"></a>为什么需要 <code>std::condition_variable</code></h4><p>如果我们在队列空的时候用 <code>while (empty) {}</code> 这种方式反复检查，就属于忙等：CPU 会空转而被白白消耗，而且线程越多锁越热。条件变量的目的就是把这种“反复检查”变成：<strong>条件不成立就睡眠阻塞；条件成立被唤醒后再检查一次</strong>。</p>
<p><code>std::condition_variable</code> 的定位是：配合 <code>std::mutex</code>，让线程在某个条件满足之前阻塞等待，并由其他线程在修改条件后发出通知。</p>
<h4 id="wait-lock-predicate-的标准写法与虚假唤醒"><a href="#wait-lock-predicate-的标准写法与虚假唤醒" class="headerlink" title="wait(lock, predicate) 的标准写法与虚假唤醒"></a><code>wait(lock, predicate)</code> 的标准写法与虚假唤醒</h4><p><strong>条件变量的 <code>wait</code> 返回，只能说明“现在应该再检查一次条件”，而不能说明“条件已经满足”</strong>。原因是：标准库允许线程在没有收到 <code>notify_one()/notify_all()</code> 的情况下，从 <code>wait</code> 中返回——这就叫<strong>虚假唤醒（spurious wakeup）</strong>。cppreference 在描述 <code>std::condition_variable</code> 的等待行为时也明确提到：<code>wait</code> 会挂起线程，直到被通知、超时，或发生虚假唤醒，然后再重新获取互斥锁返回。</p>
<p>为什么要允许这种行为？我们不需要钻到内核细节里，只要记住它是“实现层面为了兼容性与效率而允许的行为”。因此它不是程序逻辑错误，也不是异常能捕获的情况；我们要做的是<strong>写出天然兼容虚假唤醒的等待代码</strong>。</p>
<h5 id="规范写法：醒来以后必须重新检查条件"><a href="#规范写法：醒来以后必须重新检查条件" class="headerlink" title="规范写法：醒来以后必须重新检查条件"></a>规范写法：醒来以后必须重新检查条件</h5><p>最常见的坑是把等待写成 “if + wait”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::unique_lock&lt;std::mutex&gt; lk(m);</span><br><span class="line">if (q.empty()) &#123;          // 只检查一次</span><br><span class="line">    cv.wait(lk);          // 可能因为虚假唤醒返回</span><br><span class="line">&#125;</span><br><span class="line">// 如果这里仍然是空队列，下面就出错了</span><br><span class="line">auto x = q.front();</span><br><span class="line">q.pop();</span><br></pre></td></tr></table></figure>

<p>这段代码的问题在于：我们只在进入 <code>wait</code> 前检查了一次 <code>q.empty()</code>。如果线程“醒来”时队列仍为空（可能是虚假唤醒，也可能是别的线程先把数据拿走了），我们仍会继续执行 <code>front()/pop()</code>，逻辑就崩了。</p>
<p>正确写法有两种，本质完全一样：</p>
<p>1）<strong>推荐写法：用带谓词的 <code>wait</code> 重载</strong><br>它把“醒来后再次检查条件”封装好了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">cv.<span class="built_in">wait</span>(lk, [&amp;]&#123; <span class="keyword">return</span> !q.<span class="built_in">empty</span>(); &#125;); <span class="comment">// 条件不满足就继续等</span></span><br><span class="line"><span class="keyword">auto</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure>

<p>这个重载就是用来忽略&#x2F;处理虚假唤醒的。</p>
<p>2）<strong>等价写法：手写 while 循环</strong><br>更直白：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure>

<p>这两种写法的核心思想是一样的：<strong>把 <code>wait</code> 当成“可能会醒”的睡眠，而把 predicate&#x2F;while 当成“真正的条件门槛”</strong>。醒来只是提示我们“再看一眼共享状态”，而不是承诺“状态已经满足”。</p>
<blockquote>
<ul>
<li>等待条件变量时，**默认使用 **<code>cv.wait(lock, predicate)</code>（最不容易写错）。</li>
<li>如果必须用不带 predicate 的 <code>wait</code>，也必须写成 <code>while</code> 重新检查条件，**禁止 **<code>if + wait</code>。</li>
</ul>
<p>这样写不仅能规避虚假唤醒，也能顺带规避另一类常见问题：通知与条件检查之间的竞态（醒来时条件未必仍成立），整体更稳。</p>
</blockquote>
<h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h3><h4 id="信号量是什么：计数许可"><a href="#信号量是什么：计数许可" class="headerlink" title="信号量是什么：计数许可"></a>信号量是什么：计数许可</h4><p>如果说 mutex 是“同一时刻只能一个人进”，信号量更像“发放若干张许可证”：许可证 &gt; 0 时允许进入并扣减一张；许可证为 0 时就阻塞等待。这个抽象通常称为计数信号量（counting semaphore）。值只在 0&#x2F;1 的情形称为二值信号量（binary semaphore）。</p>
<h4 id="semaphore-vs-mutex-cv：各自擅长什么"><a href="#semaphore-vs-mutex-cv：各自擅长什么" class="headerlink" title="semaphore vs mutex&#x2F;cv：各自擅长什么"></a>semaphore vs mutex&#x2F;cv：各自擅长什么</h4><p>我们可以用一句话区分三者的“表达力”：</p>
<ul>
<li>mutex：保护临界区一致性（互斥进入）</li>
<li>condition_variable：等待“某个条件成立”（需要 mutex + predicate）</li>
<li>semaphore：表达“资源数量&#x2F;并发许可”（天然就是计数）</li>
</ul>
<p>信号量通常不直接保证数据结构一致性：它解决“名额&#x2F;数量”，而共享结构的读写仍可能需要 mutex 来保护。</p>
<h4 id="规范写法"><a href="#规范写法" class="headerlink" title="规范写法"></a>规范写法</h4><p>标准库的 <code>std::counting_semaphore</code> &#x2F; <code>&lt;semaphore&gt;</code> 是 C++20 才引入的。<br>在 C++17 里，我们通常做两件事：</p>
<ul>
<li>正文讲概念与用法</li>
<li>需要代码时，用 <code>mutex + condition_variable + 计数器</code> 模拟一个最小可用的 semaphore（写法与 <code>wait(lock,pred)</code> 一样，自动处理虚假唤醒）</li>
</ul>
<p>下面给出一个最小实现，以及一个“限制最多 K 个线程同时访问资源”的 demo。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Semaphore</span><span class="params">(<span class="type">int</span> initial)</span> : count_(initial) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_)</span></span>;</span><br><span class="line">    cv_.<span class="built_in">wait</span>(lk, [&amp;] &#123; <span class="keyword">return</span> count_ &gt; <span class="number">0</span>; &#125;);</span><br><span class="line">    --count_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_)</span></span>;</span><br><span class="line">        ++count_;</span><br><span class="line">    &#125;</span><br><span class="line">    cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::mutex m_;</span><br><span class="line">std::condition_variable cv_;</span><br><span class="line"><span class="type">int</span> count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 Semaphore 已定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Semaphore <span class="title">sem</span><span class="params">(<span class="number">3</span>)</span></span>;              <span class="comment">// 最多 3 个线程同时进入</span></span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; in_flight&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; ts;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        ts.<span class="built_in">emplace_back</span>([&amp;, i] &#123;</span><br><span class="line">            sem.<span class="built_in">acquire</span>();</span><br><span class="line">            <span class="type">int</span> cur = ++in_flight;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;enter &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, in_flight=&quot;</span> &lt;&lt; cur &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">            cur = --in_flight;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;leave &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, in_flight=&quot;</span> &lt;&lt; cur &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            sem.<span class="built_in">release</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : ts) t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果运行正常，我们会看到 <code>in_flight</code> 的最大值不超过 3。</p>
<h2 id="三个经典同步问题"><a href="#三个经典同步问题" class="headerlink" title="三个经典同步问题"></a>三个经典同步问题</h2><blockquote>
<p>本章记录“生产者-消费者 &#x2F; 读者-写者 &#x2F; 哲学家就餐”三个经典问题，目的是用它们把互斥与同步工具串起来，帮助我们建立可复用的并发思维框架。需要提前说明的是：这些问题在不同约束下都有多种解法（例如偏吞吐、偏公平、偏实现简单、偏可验证），本文给出的实现更强调“语义清晰、可读性强、易于推理”，并不保证在所有平台与负载下都是性能最优或策略最公平的版本。读者可以把它们当作参考基线，在理解原理后再按具体业务目标做取舍与优化。  </p>
</blockquote>
<p>前面我们已经把两类“工具”准备好了：</p>
<ul>
<li>**线程互斥：**用锁把临界区围起来，保证共享数据的一致性</li>
<li>**线程同步：**用条件变量&#x2F;信号量让线程在“条件不满足时阻塞等待”，而不是忙等</li>
</ul>
<p>这一章我们把它们落到三个经典模型上。重点是抓住“共享状态是什么、什么时候等、什么时候唤醒”。</p>
<h3 id="生产者-消费者（有界阻塞队列）"><a href="#生产者-消费者（有界阻塞队列）" class="headerlink" title="生产者-消费者（有界阻塞队列）"></a>生产者-消费者（有界阻塞队列）</h3><p>这个问题对应非常常见的工程场景：一个线程（或多个）产生任务&#x2F;数据，另一个线程（或多个）消费任务&#x2F;数据，中间用一个缓冲区（队列）连接。核心矛盾只有两个：</p>
<ul>
<li>队列空：消费者不能硬取，需要等待</li>
<li>队列满：生产者不能硬塞，需要等待</li>
</ul>
<p>这里最容易写错的点，是把等待写成“if + wait”。我们已经强调过：<code>wait</code> 可能因为通知、也可能因为虚假唤醒返回，所以正确写法必须<strong>醒来后重新检查条</strong>”。</p>
<p>我们先把“队列的共享状态”说清楚：队列的大小 <code>q.size()</code> 决定了两个条件：</p>
<ul>
<li><code>not_empty</code>：<code>!q.empty()</code>（消费者可以取）</li>
<li><code>not_full</code>：<code>q.size() &lt; cap</code>（生产者可以放）</li>
</ul>
<p>下面是一个 C++17 的解法：一个有界 <code>BlockingQueue&lt;T&gt;</code>，用一把 <code>mutex</code> 保护队列结构，用两个条件变量分别表达 <code>not_empty</code> 与 <code>not_full</code>（一个常见的用法，值得记住）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">BlockingQueue</span><span class="params">(<span class="type">size_t</span> cap)</span> : cap_(cap) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T v)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_)</span></span>;</span><br><span class="line">    cv_not_full_.<span class="built_in">wait</span>(lk, [&amp;] &#123; <span class="keyword">return</span> q_.<span class="built_in">size</span>() &lt; cap_; &#125;); <span class="comment">// 等 not_full</span></span><br><span class="line">    q_.<span class="built_in">push</span>(std::<span class="built_in">move</span>(v));</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    cv_not_empty_.<span class="built_in">notify_one</span>(); <span class="comment">// 状态从 empty -&gt; non-empty 的方向推进</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_)</span></span>;</span><br><span class="line">    cv_not_empty_.<span class="built_in">wait</span>(lk, [&amp;] &#123; <span class="keyword">return</span> !q_.<span class="built_in">empty</span>(); &#125;); <span class="comment">// 等 not_empty</span></span><br><span class="line">    T v = std::<span class="built_in">move</span>(q_.<span class="built_in">front</span>());</span><br><span class="line">    q_.<span class="built_in">pop</span>();</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    cv_not_full_.<span class="built_in">notify_one</span>(); <span class="comment">// 状态从 full -&gt; non-full 的方向推进</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> cap_;</span><br><span class="line">std::mutex m_;</span><br><span class="line">std::condition_variable cv_not_full_;</span><br><span class="line">std::condition_variable cv_not_empty_;</span><br><span class="line">std::queue&lt;T&gt; q_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="读者-写者（读并发、写独占）"><a href="#读者-写者（读并发、写独占）" class="headerlink" title="读者-写者（读并发、写独占）"></a>读者-写者（读并发、写独占）</h3><p>我们要解决的场景很典型：同一份共享数据上，<strong>读操作彼此并不冲突</strong>，所以理想情况下可以并发执行；但<strong>写操作会改变共享数据</strong>，它必须独占，并且与任何读互斥。换句话说：</p>
<ul>
<li>允许多个读者同时进入</li>
<li>一旦有写者进入，必须保证没有任何读者&#x2F;写者同时在里面</li>
</ul>
<p>如果我们直接用普通 <code>std::mutex</code>，当然能做到正确性，但代价是：<strong>读也被串行化</strong>——明明读之间互不影响，却被迫排队，浪费并发性。C++17 的 <code>std::shared_mutex</code> 就是为此准备的：读者拿共享锁（<code>std::shared_lock</code>），写者拿独占锁（<code>std::unique_lock&lt;std::shared_mutex&gt;</code>）。不过，标准库的 <code>shared_mutex</code> 并不承诺“读者优先&#x2F;写者优先&#x2F;严格公平”这类策略；如果我们确实需要可控策略，就要自己实现一把 RWLock（读写锁）。</p>
<p>下面是三种常见策略：</p>
<p><strong>读者优先 RWLock（Readers-preference）</strong></p>
<p>只要没有写者正在写，就尽量放行读者；写者必须等到“所有读者都离开”。优点是读吞吐高，缺点是读源源不断时写者可能等很久。</p>
<p><strong>写者优先 RWLock（Writers-preference）</strong></p>
<p>一旦有写者在排队，就不再放行新的读者；这样写者不会被“不断涌入的读”饿死。优点是写延迟可控，缺点是写多时读延迟会升高。</p>
<p><strong>公平 RWLock（Phase-fair，读写轮转）</strong></p>
<p>让读和写“轮流占用舞台”。当读者批量完成后让一位写者进入，写者完成后再放行一批读者。它不追求严格 FIFO，但能避免某一方长期饥饿，同时实现复杂度可控。</p>
<h3 id="哲学家就餐（多锁死锁与规避）"><a href="#哲学家就餐（多锁死锁与规避）" class="headerlink" title="哲学家就餐（多锁死锁与规避）"></a>哲学家就餐（多锁死锁与规避）</h3><blockquote>
<p><font style="color:rgb(32, 33, 34);">哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌上有五碗意大利面，每位哲学家之间各有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和五根筷子而不是意大利面和餐叉来描述，因为吃米饭必须用两根筷子。</font></p>
<p><font style="color:rgb(32, 33, 34);">这个问题不考虑意大利面有多少，也不考虑哲学家的胃有多大。假设两者都是无限大。</font></p>
<p><font style="color:rgb(32, 33, 34);">问题在于如何设计一套规则，使得在哲学家们在完全不交谈，也就是无法知道其他人可能在什么时候要吃饭或者思考的情况下，可以在这两种状态下永远交替下去。</font></p>
</blockquote>
<p><img src="/blog/blog/assets/posts/cpp17-concurrency/1770044838688-a7df3665-97c4-4128-b8a8-173b44de42fd.png"></p>
<p>哲学家就餐用来演示一个非常典型的活性风险：死锁。场景是环形资源：每个人需要两把叉才能吃。如果所有人都按同一种顺序拿叉（比如都先拿左叉），就可能出现：</p>
<blockquote>
<ul>
<li>每个人都拿到一把叉</li>
<li>然后都在等待另一把叉</li>
<li>形成环路等待，系统没有任何线程能推进</li>
</ul>
</blockquote>
<p>这一题的价值在于：解决“多把锁怎么拿才不会死锁”的问题。我们的原则很简单：</p>
<ul>
<li>多锁要么统一顺序</li>
<li>要么一次性拿（交给标准库的死锁规避算法）</li>
</ul>
<p>可以使用 <code>std::scoped_lock</code> 进行一种标准的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">5</span>;</span><br><span class="line">    std::mutex forks[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> philosopher = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="type">int</span> left = i;</span><br><span class="line">        <span class="type">int</span> right = (i + <span class="number">1</span>) % N;</span><br><span class="line">        <span class="type">int</span> a = std::<span class="built_in">min</span>(left, right);</span><br><span class="line">        <span class="type">int</span> b = std::<span class="built_in">max</span>(left, right);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::scoped_lock <span class="title">lk</span><span class="params">(forks[a], forks[b])</span></span>; <span class="comment">// C++17：一次性锁两把（带死锁规避）</span></span><br><span class="line">        <span class="comment">// eat...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; ts;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) ts.<span class="built_in">emplace_back</span>(philosopher, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : ts) t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把“统一顺序”说得更直白一点：所有线程都遵守“先拿编号小的，再拿编号大的”，就不可能形成环路等待。再加上 <code>scoped_lock</code> 的“一次性上锁”，实现上更稳。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/QG-whz/">melonstreet - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Lynn-Zhang/p/5589944.html">进程控制块PCB结构体 task_struct 描述 - ProLyn - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/operating-systems/process-control-block-in-os/">Process Control Block in OS - GeeksforGeeks</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/smartjourneys/p/7196868.html">Linux内存管理4—虚拟地址空间管理 - jasonactions - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/operating-systems/deadlock-starvation-and-livelock/">Starvation and Livelock - GeeksforGeeks</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/False_sharing">https://en.wikipedia.org/wiki/False_sharing</a></p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/">https://en.cppreference.com/w/</a></p>
<p><a target="_blank" rel="noopener" href="https://cplusplus.com/reference/mutex/lock_guard/">https://cplusplus.com/reference/mutex/lock_guard&#x2F;</a></p>
<p><a target="_blank" rel="noopener" href="https://zhzhzhy.github.io/2021/04/18/2021/Dining_philosophers_problem/#:~:text=%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98%E6%9C%89%E6%97%B6%E4%B9%9F%E7%94%A8%E7%B1%B3%E9%A5%AD%E5%92%8C%E4%BA%94%E6%A0%B9%E7%AD%B7%E5%AD%90%E8%80%8C%E4%B8%8D%E6%98%AF%E6%84%8F%E5%A4%A7%E5%88%A9%E9%9D%A2%E5%92%8C%E9%A4%90%E5%8F%89%E6%9D%A5%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%90%83%E7%B1%B3%E9%A5%AD%E5%BF%85%E9%A1%BB%E7%94%A8%E4%B8%A4%E6%A0%B9%E7%AD%B7%E5%AD%90%E3%80%82%20%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%A5%97%E8%A7%84%E5%88%99%EF%BC%8C%E4%BD%BF%E5%BE%97%E5%9C%A8%E5%93%B2%E5%AD%A6%E5%AE%B6%E4%BB%AC%E5%9C%A8%E5%AE%8C%E5%85%A8%E4%B8%8D%E4%BA%A4%E8%B0%88%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%97%A0%E6%B3%95%E7%9F%A5%E9%81%93%E5%85%B6%E4%BB%96%E4%BA%BA%E5%8F%AF%E8%83%BD%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A6%81%E5%90%83%E9%A5%AD%E6%88%96%E8%80%85%E6%80%9D%E8%80%83%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%99%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81%E4%B8%8B%E6%B0%B8%E8%BF%9C%E4%BA%A4%E6%9B%BF%E4%B8%8B%E5%8E%BB%E3%80%82%201.%20%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%9C%A8%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%8F%89%E5%AD%90%E5%8F%AF%E7%94%A8%EF%BC%88%E6%B2%A1%E6%9C%89%E5%85%B6%E4%BB%96%E4%BA%BA%E6%8B%BF%E8%B5%B7%EF%BC%89%E4%B9%8B%E5%89%8D%E5%A4%84%E4%BA%8E%E6%80%9D%E8%80%83%E7%8A%B6%E6%80%81%E3%80%82%20%E5%A6%82%E6%9E%9C%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%8F%89%E5%AD%90%E5%8F%AF%E7%94%A8%EF%BC%8C%E5%B0%B1%E6%8B%BF%E8%B5%B7%E6%9D%A5%E3%80%82%202.%20%E5%93%B2%E5%AD%A6%E5%AE%B6%E7%AD%89%E5%BE%85%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%8F%89%E5%AD%90%E5%8F%AF%E7%94%A8%E3%80%82%20%E5%A6%82%E6%9E%9C%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%8F%89%E5%AD%90%E5%8F%AF%E7%94%A8%EF%BC%8C%E5%B0%B1%E6%8B%BF%E8%B5%B7%E6%9D%A5%E3%80%82,3.%20%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA%E5%8F%89%E5%AD%90%E9%83%BD%E5%B7%B2%E7%BB%8F%E6%8B%BF%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%BC%80%E5%A7%8B%E5%90%83%E6%84%8F%E5%A4%A7%E5%88%A9%E9%9D%A2%EF%BC%8C%E6%AF%8F%E6%AC%A1%E5%90%83%E9%9D%A2%E9%83%BD%E8%8A%B1%E8%B4%B9%E5%90%8C%E6%A0%B7%E7%9A%84%E6%97%B6%E9%97%B4%E3%80%82%204.%20%E5%90%83%E5%AE%8C%E5%90%8E%E5%85%88%E6%94%BE%E4%B8%8B%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%8F%89%E5%AD%90%E3%80%82%205.%20%E7%84%B6%E5%90%8E%E6%94%BE%E4%B8%8B%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%8F%89%E5%AD%90%E3%80%82%206.%20%E5%BC%80%E5%A7%8B%E6%80%9D%E8%80%83%EF%BC%88%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E5%BE%AA%E7%8E%AF%EF%BC%89">哲学家进餐问题(Dining philosophers problem)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98</a></p>
</article>
<div class="article-footer">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    

</div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"></div><div class="item" id="next"><div class="note">较早文章</div><a href="/blog/2026/02/01/hello-world/">Hello World</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="sitemap" style="column-count:3;"><div class="sitemap-group"><span class="fs15">博客</span><a href="https://kamill7779.github.io/blog/">最新</a><a href="https://kamill7779.github.io/blog/categories/">分类</a><a href="https://kamill7779.github.io/blog/tags/">标签</a><a href="https://kamill7779.github.io/blog/archives/">归档</a></div><div class="sitemap-group"><span class="fs15">社交</span><a target="_blank" rel="noopener" href="https://github.com/kamill7779">GitHub</a><a href="mailto:kamill7779@outlook.com">Email</a></div><div class="sitemap-group"><span class="fs15">关于</span><a href="https://kamill7779.github.io/blog/about/">关于我</a><a href="https://kamill7779.github.io/blog/friends/">友情链接</a></div></div><div class="text"><p>你好，我是 Kamil Liu，这里记录算法、工程实践与日常笔记。<br>本站使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题构建。<br>本站文章默认采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%88%B0%E5%BA%95%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%EF%BC%9A%E5%B9%B6%E5%8F%91-vs-%E5%B9%B6%E8%A1%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%8E%B0%E5%AE%9E%E7%BA%A6%E6%9D%9F"><span class="toc-text">并发到底解决什么：并发 vs 并行、线程模型与现实约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%B9%B6%E5%8F%91%EF%BC%88Concurrency%EF%BC%89vs-%E5%B9%B6%E8%A1%8C%EF%BC%88Parallelism%EF%BC%89"><span class="toc-text">1.1 并发（Concurrency）vs 并行（Parallelism）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%BF%9B%E7%A8%8B-vs-%E7%BA%BF%E7%A8%8B%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E9%80%9A%E5%B8%B8%E5%9C%A8%E2%80%9C%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E2%80%9D%E4%B8%8B%E6%9C%80%E5%85%B8%E5%9E%8B"><span class="toc-text">1.2 进程 vs 线程：为什么同步问题通常在“线程共享内存”下最典型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B"><span class="toc-text">1) 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B"><span class="toc-text">2) 线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-text">3) 程序的虚拟内存布局：为什么线程共享内存会触发同步问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%BA%BF%E7%A8%8B%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-text">1.3 线程越多越好吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%BC%80%E9%94%80%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8D%E6%98%AF%E9%9B%B6%E6%88%90%E6%9C%AC%E5%AF%B9%E8%B1%A1"><span class="toc-text">1) 创建开销：线程不是零成本对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80%EF%BC%9ACPU-%E6%97%B6%E9%97%B4%E8%A2%AB%E6%B6%88%E8%80%97%E5%9C%A8%E2%80%9C%E5%88%87%E6%8D%A2%E2%80%9D%E8%80%8C%E9%9D%9E%E2%80%9C%E8%AE%A1%E7%AE%97%E2%80%9D"><span class="toc-text">2) 上下文切换开销：CPU 时间被消耗在“切换”而非“计算”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E9%A6%96%E5%85%88%E6%B6%88%E8%80%97%E7%9A%84%E6%98%AF%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86%E5%BC%80%E9%94%80"><span class="toc-text">3) 资源占用：线程数量首先消耗的是内存与内核管理开销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BB%93%E8%AE%BA%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%B8%8D%E6%98%AF%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%EF%BC%8C%E8%80%8C%E6%98%AF%E8%A6%81%E2%80%9C%E5%A4%9F%E7%94%A8%E4%B8%94%E5%8F%AF%E6%8E%A7%E2%80%9D"><span class="toc-text">4) 结论：线程数不是越多越好，而是要“够用且可控”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E9%94%99%EF%BC%9A%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%E3%80%81%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E2%80%9C%E5%A4%9A%E7%BA%BF%E7%A8%8B-1%E2%80%9D%E7%9B%B4%E8%A7%82%E6%BC%94%E7%A4%BA"><span class="toc-text">并发为什么会错：竞态条件、数据竞争、原子性与“多线程 +1”直观演示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Race-Condition-vs-Data-Race"><span class="toc-text">2.1 Race Condition vs Data Race</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88Atomicity%EF%BC%89%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA%EF%BC%88Critical-Section%EF%BC%89"><span class="toc-text">2.2 原子性（Atomicity）与临界区（Critical Section）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E8%87%AA%E5%A2%9E%E6%93%8D%E4%BD%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-text">2.3 示例：多线程下的自增操作为什么线程不安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BB%8E%E2%80%9C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%9D%E8%87%AA%E7%84%B6%E8%BF%87%E6%B8%A1%E5%88%B0%E2%80%9C%E5%8F%AF%E9%87%8D%E5%85%A5%E2%80%9D%EF%BC%88%E9%81%BF%E5%85%8D%E5%BC%95%E5%85%A5%E7%AA%81%E5%85%80%EF%BC%89"><span class="toc-text">2.4 从“线程安全”自然过渡到“可重入”（避免引入突兀）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%B4%BB%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9A%E6%AD%BB%E9%94%81-%E6%B4%BB%E9%94%81-%E9%A5%A5%E9%A5%BF"><span class="toc-text">2.5 活性问题：死锁&#x2F;活锁&#x2F;饥饿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88Mutual-Exclusion%EF%BC%89"><span class="toc-text">线程互斥（Mutual Exclusion）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%88Atomic%EF%BC%89%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E2%80%9C%E6%97%A0%E9%9C%80%E9%94%81%E2%80%9D%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E2%80%9C%E5%BF%85%E9%A1%BB%E9%94%81%E2%80%9D"><span class="toc-text">原子操作（Atomic）：什么时候“无需锁”，什么时候“必须锁”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-atomic-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%EF%BC%88C-17%EF%BC%89"><span class="toc-text">std::atomic 的基本语义（C++17）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%EF%BC%88Compare-And-Swap-Exchange%EF%BC%89"><span class="toc-text">CAS（Compare-And-Swap&#x2F;Exchange）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CAS-%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F%E5%85%88%E4%BB%8E%E2%80%9C%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%80%BC%E4%BC%9A%E5%8F%98%E2%80%9D%E8%AF%B4%E8%B5%B7"><span class="toc-text">CAS 在干什么？先从“并发下值会变”说起</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-CAS-%E6%80%BB%E6%98%AF%E5%92%8C%E2%80%9C%E5%BE%AA%E7%8E%AF%E2%80%9D%E7%BB%91%E5%AE%9A%EF%BC%9F"><span class="toc-text">为什么 CAS 总是和“循环”绑定？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%94%A8-CAS-%E5%AE%9E%E7%8E%B0-%E2%80%9C%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E2%80%9D"><span class="toc-text">示例：用 CAS 实现 “原子更新最大值”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#atomic-%E7%9A%84%E8%BE%B9%E7%95%8C%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E2%80%9C%E5%A4%8D%E5%90%88%E4%B8%8D%E5%8F%98%E9%87%8F%E2%80%9D%E4%BB%8D%E9%9C%80%E8%A6%81%E9%94%81"><span class="toc-text">atomic 的边界：为什么“复合不变量”仍需要锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%80%A7%E8%83%BD%E9%99%B7%E9%98%B1%EF%BC%9A%E4%BC%AA%E5%85%B1%E4%BA%AB%EF%BC%88False-Sharing%EF%BC%89"><span class="toc-text">3.3 性能陷阱：伪共享（False Sharing）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-mutex-%E4%B8%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E6%89%8B%E5%86%99-lock-unlock"><span class="toc-text">std::mutex 与为什么不要手写 lock()&#x2F;unlock()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-lock-guard%EF%BC%9A%E9%BB%98%E8%AE%A4%E9%A6%96%E9%80%89"><span class="toc-text">std::lock_guard：默认首选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-unique-lock%EF%BC%9A%E4%B8%BA%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E6%9B%B4%E5%A4%8D%E6%9D%82%E6%B5%81%E7%A8%8B%E5%87%86%E5%A4%87"><span class="toc-text">std::unique_lock：为条件变量与更复杂流程准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%8A%8A%E9%94%81%E7%9A%84%E6%A0%87%E5%87%86%E8%A7%A3%EF%BC%9Astd-scoped-lock-std-lock"><span class="toc-text">多把锁的标准解：std::scoped_lock &#x2F; std::lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%EF%BC%9Astd-shared-mutex-std-shared-lock"><span class="toc-text">读多写少：std::shared_mutex + std::shared_lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%88Synchronization%EF%BC%89"><span class="toc-text">线程同步（Synchronization）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%9A%E4%BB%8E%E5%BF%99%E7%AD%89%E5%88%B0%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85"><span class="toc-text">条件变量：从忙等到阻塞等待</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-std-condition-variable"><span class="toc-text">为什么需要 std::condition_variable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-lock-predicate-%E7%9A%84%E6%A0%87%E5%87%86%E5%86%99%E6%B3%95%E4%B8%8E%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="toc-text">wait(lock, predicate) 的标准写法与虚假唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E5%86%99%E6%B3%95%EF%BC%9A%E9%86%92%E6%9D%A5%E4%BB%A5%E5%90%8E%E5%BF%85%E9%A1%BB%E9%87%8D%E6%96%B0%E6%A3%80%E6%9F%A5%E6%9D%A1%E4%BB%B6"><span class="toc-text">规范写法：醒来以后必须重新检查条件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89"><span class="toc-text">信号量（Semaphore）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A%E8%AE%A1%E6%95%B0%E8%AE%B8%E5%8F%AF"><span class="toc-text">信号量是什么：计数许可</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#semaphore-vs-mutex-cv%EF%BC%9A%E5%90%84%E8%87%AA%E6%93%85%E9%95%BF%E4%BB%80%E4%B9%88"><span class="toc-text">semaphore vs mutex&#x2F;cv：各自擅长什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E5%86%99%E6%B3%95"><span class="toc-text">规范写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-text">三个经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88%E6%9C%89%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-text">生产者-消费者（有界阻塞队列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%EF%BC%88%E8%AF%BB%E5%B9%B6%E5%8F%91%E3%80%81%E5%86%99%E7%8B%AC%E5%8D%A0%EF%BC%89"><span class="toc-text">读者-写者（读并发、写独占）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%EF%BC%88%E5%A4%9A%E9%94%81%E6%AD%BB%E9%94%81%E4%B8%8E%E8%A7%84%E9%81%BF%EF%BC%89"><span class="toc-text">哲学家就餐（多锁死锁与规避）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/blog/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/blog/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/blog/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
